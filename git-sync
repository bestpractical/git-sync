#!/usr/bin/env perl

# Simple usage:
# add the config found after __END__ to your config
# the script will search like git does, so
# ./.git/config, ~/.gitconfig, /etc/gitconfig
#
# $ git sync
# syncs all sync sections of your config
# $ git sync bps
# syncs only one of the sections

use Config::GitLike::Git;
use Git;
use strict;
use warnings;
use Term::ANSIColor;
use Getopt::Long;

my ($verbose, $pretend);
GetOptions(
    'verbose|v' => \$verbose,
    'pretend|dry-run' => \$pretend,
);

my %conf = Config::GitLike::Git->new->load;

my %sync;
for (keys %conf) {
    next unless /^sync\.(.*?)\.(.*)$/;
    $sync{$1}{$2} = $conf{$_};
}

my @categories;
if (@ARGV) {
    for my $name (@ARGV) {
        die qq{Can't find sync named "$name"\n} unless exists $sync{$name};
        push @categories, $name;
    }
} else {
    @categories = sort {exists $sync{$a}{local} <=> exists $sync{$b}{local} or $a cmp $b} keys %sync;
}

my %seen;
for my $name (@categories) {
    print colored("Syncing" . (length $name ? " $name" : "")."\n", "bold");

    unless ($sync{$name}{into}) {
        print colored("  No 'into' set, skipping!\n", "red");
        next;
    }
    if (exists $sync{$name}{local}) {
        sync_all_local($name);
    } else {
        unless ($sync{$name}{host}) {
            print colored("  No 'host' set, skipping!\n", "red");
            next;
        }
        unless ($sync{$name}{path}) {
            print colored("  No 'path' set, skipping!\n", "red");
            next;
        }
        sync_all_remote($name);
    }
    print " "x45,"\n";
}

sub sync_all_local {
    my $name = shift;
    foreach my $into ( ref $sync{$name}{into} ? @{$sync{$name}{into}} : $sync{$name}{into} ) {
        for my $root (grep {-d} <$into/*>) {
            $root =~ m{/([^/]+)(?:\.git)?$};
            printf "  %-40s ", $1;
            if (exists $seen{$root}) {
                print $verbose ? colored("[ Already synchronized ]\n", "dark") : "\r";
                next;
            }
            update($root, 0);
            $seen{$root} = "";
        }
    }
}

sub sync_all_remote {
    my $name = shift;
    my @paths = ref $sync{$name}{path} ? @{$sync{$name}{path}} : ($sync{$name}{path});
    for my $path (@paths) {
        my @list = `ssh $sync{$name}{host} ls $path`;
        warn("Listing returned ".($? >> 8).", skipping!\n") and next if $?;
        for my $reponame (@list) {
            $reponame =~ s/(\.git)?\n?$//;
            my $root = "$sync{$name}{into}/$reponame";

            printf "  %-40s ", $reponame;
            if ($seen{$root}) {
                print colored( "[ Already synchronized! ]\n", "red");
                next;
            } elsif (exists $seen{$root}) {
                print $verbose ? colored("[ Already synchronized ]\n", "dark") : "\r";
                next;
            }
            $seen{$root} = $name;
            if (-e $root) {
                update($root, 1);
            } else {
                `ssh $sync{$name}{host} [ -e $path/${reponame}.git/config ]`;
                print $verbose ? colored("[ Not a git repository ]\n", "dark") : "\r" and next
                    if $?;

                my ($ignore) = `ssh $sync{$name}{host} git config --bool -f $path/${reponame}.git/config  sync.ignore`;
                chomp $ignore if defined $ignore;
                print $verbose ? colored("[ sync.ignore set ]\n", "dark") : "\r" and next
                    if defined $ignore and $ignore eq 'true';

                new($root => "$sync{$name}{host}:$path/$reponame", $sync{$name}{email});
            }
        }
    }
}

sub update {
    my ($root, $force) = @_;

    # Already exists, fetch and possibly rebase
    my $repo = eval { Git->repository(Directory => $root) };
    unless ($repo) {
        print $force ? colored("[ Not a git repository! ]\n", "bold red") : "\r";
        return;
    }

    my $gitsvn = -e $repo->repo_path . "/svn/.metadata";
    if ($gitsvn) {
        print colored( "[ svn ] ", "dark blue" );
         # git-svn doesn't work with $repo->command, hate
        `git --git-dir @{[$repo->repo_path]} svn fetch -q` unless $pretend;
    } else {
        eval { $repo->command( ["fetch"], STDERR => 0 ); } unless $pretend;
    }

    my $error = $@; chomp $error;
    print colored("[ Fetch failed! $error]\n", "bold red") and return if $@;

    print colored("[ Fetch ] ", "dark") if $pretend;

    print colored("[ Bare repository ]\n", "green") and return if $repo->config_bool('core.bare');

    my $status = "";
    my ($fh, $ctx) = $repo->command_output_pipe('status');
    $status .= $_ while (<$fh>);
    eval {$repo->command_close_pipe($fh, $ctx);};

    # Rebase if there are no changes, it is on a tracking
    # branch, and the result would be a fast-forward
    my ($branch) = $status =~ /^# On branch (.*)/m;
    $branch ||= 'Not currently on any branch';
    if ($status =~ /^# Your branch is behind '.*?' by \d+ commits?, and can be fast-forwarded/m
            and $status =~ /^nothing (?:added )?to commit/m) {
        # git-pull is a shell script, unfortunately, and
        # thus can't be run via $repo->command( "pull" )
        chdir($root);
        print colored( $pretend ? "[ Would pull ($branch) ]\n" : "[ Pulled ($branch) ]\n", "bold green" );
        my $pull = $pretend ? "" : `git pull --stat`;
        # Indent, and colorize (git doesn't, because we're not a tty)
        $pull =~ s/^/    /gm if length $pull;
        $pull =~ s/^(  .*?)(\+*)(-*)$/$1.colored($2,"green").colored($3,"red")/gme;
        print $pull;
    } else {
        if ($status =~ /^# Your branch and '.*?' have diverged.*?(\d+) and (\d+) different commit/sm) {
            print colored( "[ Diverged by $1 and $2 commits ($branch) ]", "bold blue" );
        } elsif ($status =~ /^# Your branch is ahead of '.*?' by (\d+) commit/m) {
            print colored( "[ Ahead by $1 ($branch) ]", "bold blue");
        } elsif ($status =~ /^# Your branch is behind '.*?' by (\d+) commit/m) {
            print colored( "[ Behind by $1 ($branch) ]", "bold blue");
        } else {
            print colored( "[ Up-to-date ($branch) ]", "green");
        }
        if ($status !~ /^nothing (?:added )?to commit/m) {
            print colored( " [ Dirty ]", "yellow");
        }
        print "\n";
    }

    # Purge old tracking branches
    $repo->command( qw/remote prune origin/ ) unless $gitsvn or $pretend;
}

sub new {
    # Path to clone into, path to clone from, user
    my ($into, $from, $email) = @_;

    print colored("[ Would clone $from into $into ]\n", "bold green") and return if $pretend;

    my $ret = eval { Git::command( [clone => $from => $into], STDERR => 0 ) };
    if ($@) {
        print colored( "[ Clone failed! ]\n", "bold red");
        return;
    }
    Git::command( config => "--file", "$into/.git/config", "user.email", $email )
          if $email;
    print colored( "[ Cloned! ]\n", "bold green");
}

__END__
[sync "bps"]
    host = fsck.com
    path = /git
    path = /git-private
    into = /home/chmrr/work/bps/git
    email = alexmv@bestpractical.com
[sync "localrepos"]
    into = /home/chmrr/gitprojects
    local = true
