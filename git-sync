#!/usr/bin/env perl

# Simple usage:
# add the config found after __END__ to your config
# the script will search like git does, so
# ./.git/config, ~/.gitconfig, /etc/gitconfig
#
# $ git sync
# syncs all sync sections of your config
# $ git sync bps
# syncs only one of the sections

use Config::GitLike::Git;
use Git;
use strict;
use warnings;
use Term::ANSIColor;
use Getopt::Long;
use LWP::Simple qw();
use File::Path qw();

$SIG{INT} = sub {
    print colored("\n\nInterrupted!\n", "bold red");
    exit;
};

my ($verbose, $pretend, $log);
GetOptions(
    'verbose|v' => \$verbose,
    'pretend|dry-run' => \$pretend,
    'log|l' => \$log,
);

my %conf = Config::GitLike::Git->new->load;

my %sync;
for (keys %conf) {
    next unless /^sync\.(.*?)\.(.*)$/;
    $sync{$1}{$2} = $conf{$_};
}

my @categories;
if (@ARGV) {
    for my $name (@ARGV) {
        die qq{Can't find sync named "$name"\n} unless exists $sync{$name};
        push @categories, $name;
    }
} else {
    @categories = sort {exists $sync{$a}{local} <=> exists $sync{$b}{local} or $a cmp $b} keys %sync;
}

my %seen;
for my $name (@categories) {
    print colored("Syncing" . (length $name ? " $name" : "")."\n", "bold");

    if (not $sync{$name}{into}) {
        print colored("  No 'into' set, skipping!\n", "red");
    } elsif (exists $sync{$name}{local}) {
        sync_all_local(%{$sync{$name}});
    } elsif (exists $sync{$name}{github}) {
        sync_all_github(%{$sync{$name}});
    } else {
        sync_all_remote(%{$sync{$name}});
    }
    print " "x45,"\n";
}

sub sync_all_local {
    my %config = @_;
    foreach my $into ( ref $config{into} ? @{$config{into}} : $config{into} ) {
        unless (-d $into) {
            print colored("  Directory '$into' does not exist!\n", "bold red");
            next;
        }
        for my $root (grep {-d} <$into/*>) {
            $root =~ m{/([^/]+)(?:\.git)?$};
            printf "  %-40s ", $1;
            next if already($root => 0);
            update($root, 0);
        }
    }
}

sub sync_all_github {
    my %config = @_;

    print colored("  Only one value valid for 'into' when 'github' supplied", "red") and return
        if ref $config{into};

    unless (-d $config{into}) {
        print colored("  Creating directory '$config{into}'\n", "bold");
        print colored("  Directory creation failed: $!\n", "bold red") and return
            unless eval { File::Path::mkpath($config{into}) };
    }

    my $decoder = eval { require JSON::Any; JSON::Any->import; JSON::Any->new };
    print colored("  GitHub sync support requires the JSON::Any module\n", "red") and return
        if $@ or not $decoder;

    my @accounts = ref $config{github} ? @{$config{github}} : ($config{github});
    for my $acct (@accounts) {
        my $content = LWP::Simple::get("http://github.com/api/v1/json/$acct");
        print colored("  GET of http://github.com/api/v1/json/$acct failed!\n", "bold red") and next
            unless defined $content;

        my $data = eval {$decoder->jsonToObj($content)};
        print colored("  Parsing of GitHub JSON response failed! $@\n", "bold red")."\n$content\n" and next
            unless defined $data;

        for my $repo (@{$data->{user}{repositories} || []}) {
            my $reponame = $repo->{name};
            my $root = "$config{into}/$reponame";

            printf "  %-40s ", $reponame;
            next if already($root => 1);
            if (-e $root) {
                update($root, 1);
            } else {
                new($root => "git\@github.com:$acct/$reponame.git" => $config{email});
            }
        }
    }
}

sub sync_all_remote {
    my %config = @_;

    print colored("  No 'host' set, skipping!\n", "red") and return
        unless $config{host};

    print colored("  No 'path' set, skipping!\n", "red") and return
        unless $config{path};

    print colored("  Only one value valid for 'into' when 'host' supplied!\n", "red") and return
        if ref $config{into};

    unless (-d $config{into}) {
        print colored("  Creating directory '$config{into}'\n", "bold");
        print colored("  Directory creation failed: $!\n", "bold red") and return
            unless eval { File::Path::mkpath($config{into}) };
    }

    my @paths = ref $config{path} ? @{$config{path}} : ($config{path});
    for my $path (@paths) {
        my @list = `ssh $config{host} ls $path`;
        print colored("  Listing returned ".($? >> 8).", skipping!\n", "bold red") and next if $?;
        for my $reponame (@list) {
            $reponame =~ s/(\.git)?\n?$//;
            my $into = "$config{into}/$reponame";

            printf "  %-40s ", $reponame;
            next if already($into => 1);
            if (-e $into) {
                update($into, 1);
            } else {
                `ssh $config{host} [ -e $path/${reponame}.git/config ]`;
                print $verbose ? colored("[ Not a git repository ]\n", "dark") : "\r" and next
                    if $?;

                my ($ignore) = `ssh $config{host} git config --bool -f $path/${reponame}.git/config sync.ignore`;
                chomp $ignore if defined $ignore;
                print $verbose ? colored("[ sync.ignore set ]\n", "dark") : "\r" and next
                    if defined $ignore and $ignore eq 'true';

                new($into => "$config{host}:$path/$reponame", $config{email});
            }
        }
    }
}

sub already {
    my ($path, $force) = @_;
    if ($force and $seen{$path}) {
        print colored( "[ Already synchronized! ]\n", "red");
        return 1;
    } elsif (exists $seen{$path}) {
        print $verbose ? colored("[ Already synchronized ]\n", "dark") : "\r";
        return 1;
    }
    $seen{$path} = $force;
    return;
}

sub update {
    my ($root, $force) = @_;

    # Already exists, fetch and possibly rebase
    my $repo = eval { Git->repository(Directory => $root) };
    unless ($repo) {
        print $force ? colored("[ Not a git repository! ]\n", "bold red") : "\r";
        return;
    }

    my $gitsvn = -e $repo->repo_path . "/svn/.metadata";
    if ($gitsvn) {
        print colored( "[ svn ] ", "dark blue" );
         # git-svn doesn't work with $repo->command, hate
        `git --git-dir @{[$repo->repo_path]} svn fetch -q` unless $pretend;
    } else {
        my $ret = eval { $repo->command( qw/remote update --prune/ ); } unless $pretend;
    }
    kill $? & 127, $$ if $? & 127;

    my $error = $@; chomp $error;
    print colored("[ Fetch failed! $error]\n", "bold red") and return if $@;

    print colored("[ Fetch ] ", "dark") if $pretend;

    print colored("[ Bare repository ]\n", "green") and return if $repo->config_bool('core.bare');

    my $status = "";
    my ($fh, $ctx) = $repo->command_output_pipe('status');
    $status .= $_ while (<$fh>);
    eval {$repo->command_close_pipe($fh, $ctx);};

    # Rebase if there are no changes, it is on a tracking
    # branch, and the result would be a fast-forward
    my ($branch) = $status =~ /^# On branch (.*)/m;
    $branch ||= 'Not currently on any branch';
    if ($status =~ /^nothing (?:added )?to commit/m
            and $status =~ /^# Your branch is behind '(.*?)' by (\d+) commits?, and can be fast-forwarded/m) {
        my ($tracking, $behind) = ($1, $2);
        # git-pull is a shell script, unfortunately, and
        # thus can't be run via $repo->command( "pull" )
        chdir($root);
        print colored( $pretend ?
                           "[ Would pull $behind commits ($branch) ]\n" :
                           "[ Pulled $behind commits ($branch) ]\n",
                       "bold green" );

        print logs($repo, $branch => $tracking);

        my $pull = $pretend ? "" : `git pull --stat`;
        kill $? & 127, $$ if $? & 127;

        # This line will always be present, and is content-free
        $pull =~ s/^First, rewinding head.*?\n//m;
        # Indent, and colorize (git doesn't, because we're not a tty)
        $pull =~ s/^( .*?)(\+*)(-*)$/$1.colored($2,"green").colored($3,"red")/gme;
        $pull =~ s/^/    /gm if length $pull;
        print $pull;
    } else {
        my $logs = "";
        if ($status =~ /^# Your branch and '.*?' have diverged.*?(\d+) and (\d+) different commit/sm) {
            print colored( "[ Diverged by $1 and $2 commits ($branch) ]", "bold cyan" );
        } elsif ($status =~ /^# Your branch is ahead of '(.*?)' by (\d+) commit/m) {
            my ($tracking, $ahead) = ($1, $2);
            print colored( "[ Ahead by $ahead ($branch) ]", "bold blue");
            $logs = logs($repo, $tracking => $branch);
        } elsif ($status =~ /^# Your branch is behind '(.*?)' by (\d+) commit/m) {
            my ($tracking, $behind) = ($1, $2);
            print colored( "[ Behind by $behind ($branch) ]", "bold magenta");
            $logs = logs($repo, $branch => $tracking);
        } else {
            print colored( "[ Up-to-date ($branch) ]", "green");
        }
        if ($status !~ /^nothing (?:added )?to commit/m) {
            print colored( " [ Dirty ]", "yellow");
        }
        print "\n$logs";
    }

}

sub new {
    # Path to clone into, path to clone from, user
    my ($into, $from, $email) = @_;
    local $?;

    print colored("[ Would clone $from into $into ]\n", "bold green") and return if $pretend;

    my $ret = eval { Git::command( [clone => "-q" => $from => $into], STDERR => 0 ) };
    if ($@) {
        print colored( "[ Clone failed! ]\n", "bold red");
        print colored( "Error: $@\n", "red") if ($verbose);
        return;
    }
    kill $? & 127, $$ if $? & 127;

    Git::command( config => "--file", "$into/.git/config", "user.email", $email )
          if $email;
    print colored( "[ Cloned! ]\n", "bold green");
}

sub logs {
    my ($repo, $from, $to) = @_;
    return "" unless $log;
    my $logmsg = $repo->command( log => "--oneline", "--reverse", "$from..$to" );
    # Re-colorize and indent
    $logmsg =~ s/^(\S+)/"    ".colored($1,"yellow")/egm;
    return $logmsg;
}

__END__
[sync "bps"]
    host = fsck.com
    path = /git
    path = /git-private
    into = /home/chmrr/work/bps/git
    email = alexmv@bestpractical.com
[sync "localrepos"]
    into = /home/chmrr/gitprojects
    local = true
[sync "github"]
    into = /home/chmrr/github
    github = alexmv
